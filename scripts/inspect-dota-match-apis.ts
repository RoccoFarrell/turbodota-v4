/**
 * Inspect Dota 2 match API payloads (OpenDota + Stratz).
 * Run: npx tsx scripts/inspect-dota-match-apis.ts
 *
 * Optional env:
 *   OPENDOTA_ACCOUNT_ID - fetch OpenDota player matches list (one page)
 *   OPENDOTA_MATCH_ID   - fetch OpenDota match details (default: 4896520517)
 *   STRATZ_TOKEN        - fetch Stratz GraphQL player matches (one page)
 *
 * Writes: scripts/dota-match-api-payloads.md (summary of shapes and available stats).
 */

import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const scriptDir = dirname(fileURLToPath(import.meta.url));
const OUT_FILE = join(scriptDir, 'dota-match-api-payloads.md');

// --- OpenDota: player matches list ---
// GET https://api.opendota.com/api/players/{account_id}/matches?limit=20&offset=0&date=30
async function fetchOpenDotaPlayerMatches(accountId: number): Promise<unknown[]> {
	const url = `https://api.opendota.com/api/players/${accountId}/matches?significant=0&date=30&limit=5`;
	const res = await fetch(url);
	if (!res.ok) throw new Error(`OpenDota player matches ${res.status}: ${await res.text()}`);
	return res.json();
}

// --- OpenDota: match details ---
// GET https://api.opendota.com/api/matches/{match_id}
async function fetchOpenDotaMatchDetail(matchId: number): Promise<unknown> {
	const url = `https://api.opendota.com/api/matches/${matchId}`;
	const res = await fetch(url);
	if (!res.ok) throw new Error(`OpenDota match detail ${res.status}: ${await res.text()}`);
	return res.json();
}

// --- Stratz: GraphQL player matches ---
async function fetchStratzPlayerMatches(accountId: number, token: string): Promise<unknown> {
	const query = `
	query {
		player(steamAccountId: ${accountId}) {
			steamAccountId
			matches(request: { take: 3, gameModeIds: [23] }) {
				id
				gameMode
				startDateTime
				endDateTime
				durationSeconds
				isStats
				didRadiantWin
				averageRank
				players(steamAccountId: ${accountId}) {
					steamAccountId
					isRadiant
					isVictory
					heroId
					kills
					assists
					deaths
					leaverStatus
					playerSlot
					award
					imp
					heroDamage
					towerDamage
					heroHealing
				}
			}
		}
	}
	`;
	const res = await fetch('https://api.stratz.com/graphql', {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			Authorization: `Bearer ${token}`
		},
		body: JSON.stringify({ query })
	});
	if (!res.ok) throw new Error(`Stratz ${res.status}: ${await res.text()}`);
	const data = await res.json();
	if (data.errors) throw new Error(`Stratz GraphQL errors: ${JSON.stringify(data.errors)}`);
	return data;
}

async function main() {
	const accountId = process.env.OPENDOTA_ACCOUNT_ID ? parseInt(process.env.OPENDOTA_ACCOUNT_ID, 10) : null;
	const matchId = process.env.OPENDOTA_MATCH_ID ? parseInt(process.env.OPENDOTA_MATCH_ID, 10) : 4896520517;
	const stratzToken = process.env.STRATZ_TOKEN ?? '';

	const sections: string[] = [];
	sections.push('# Dota 2 match API payloads (inspect script output)\n');
	sections.push('Generated by `scripts/inspect-dota-match-apis.ts`. Use for reward/lootbox design.\n');

	// 1) OpenDota player matches list
	sections.push('## 1. OpenDota – Player matches list\n');
	sections.push('**Endpoint:** `GET https://api.opendota.com/api/players/{account_id}/matches?significant=0&date=30&limit=5`\n');
	if (accountId) {
		try {
			const list = await fetchOpenDotaPlayerMatches(accountId) as unknown[];
			sections.push('**Shape (first item):**\n```json\n' + JSON.stringify(list[0] ?? {}, null, 2) + '\n```\n');
			sections.push('**Keys:** ' + (list[0] ? Object.keys(list[0] as object).join(', ') : 'N/A') + '\n');
		} catch (e) {
			sections.push('**Error:** ' + (e instanceof Error ? e.message : String(e)) + '\n');
		}
	} else {
		sections.push('*Set `OPENDOTA_ACCOUNT_ID` and re-run to fetch. From code/schema we use:*\n');
		sections.push('- `match_id`, `start_time`, `player_slot`, `radiant_win`, `hero_id`, `kills`, `deaths`, `assists`, `duration`, `game_mode`, `leaver_status`, `average_rank` (and optionally more from OpenDota list).\n');
		sections.push('- **Stored in DB `Match`:** match_id, account_id, kills, assists, deaths, duration, game_mode, hero_id, player_slot, radiant_win, start_time, average_rank, leaver_status, lobby_type, party_size, skill, hero_variant, version.\n');
	}

	// 2) OpenDota match details
	sections.push('## 2. OpenDota – Match details\n');
	sections.push('**Endpoint:** `GET https://api.opendota.com/api/matches/{match_id}`\n');
	try {
		const detail = await fetchOpenDotaMatchDetail(matchId) as Record<string, unknown>;
		const players = detail.players as Record<string, unknown>[] | undefined;
		sections.push('**Match-level keys:** ' + Object.keys(detail).filter(k => k !== 'players').join(', ') + '\n');
		if (players?.[0]) {
			sections.push('**Player-level keys (first player):** ' + Object.keys(players[0]).join(', ') + '\n');
			sections.push('**Sample player (first):**\n```json\n' + JSON.stringify(players[0], null, 2).slice(0, 2000) + '\n```\n');
		}
	} catch (e) {
		sections.push('**Error:** ' + (e instanceof Error ? e.message : String(e)) + '\n');
	}

	// 3) Stratz GraphQL
	sections.push('## 3. Stratz – Player matches (GraphQL)\n');
	sections.push('**Endpoint:** `POST https://api.stratz.com/graphql` with Bearer token.\n');
	sections.push('**Query:** `player(steamAccountId)` → `matches(request: { take, gameModeIds })` → `id`, `durationSeconds`, `didRadiantWin`, `players(steamAccountId)` → `heroId`, `kills`, `assists`, `deaths`, `heroDamage`, `towerDamage`, `heroHealing`, `award`, `imp`, etc.\n');
	if (stratzToken && accountId) {
		try {
			const stratz = await fetchStratzPlayerMatches(accountId, stratzToken) as Record<string, unknown>;
			sections.push('**Sample response (data.player.matches[0]):**\n```json\n' + JSON.stringify(stratz, null, 2).slice(0, 2500) + '\n```\n');
		} catch (e) {
			sections.push('**Error:** ' + (e instanceof Error ? e.message : String(e)) + '\n');
		}
	} else {
		sections.push('*Set `STRATZ_TOKEN` and `OPENDOTA_ACCOUNT_ID` to fetch. From code we use:*\n');
		sections.push('- Match: `id`, `gameMode`, `startDateTime`, `endDateTime`, `durationSeconds`, `didRadiantWin`, `averageRank`, `isStats`.\n');
		sections.push('- Player: `heroId`, `kills`, `assists`, `deaths`, `isVictory`, `leaverStatus`, `playerSlot`, `award`, `imp`, `heroDamage`, `towerDamage`, `heroHealing`.\n');
	}

	// 4) Stats available for rewards (summary)
	sections.push('## 4. Stats available for rewards (summary)\n');
	sections.push('| Source | Available in list (no extra call) | Available in detail (per match fetch) |\n');
	sections.push('|--------|-----------------------------------|--------------------------------------|\n');
	sections.push('| **OpenDota** | match_id, start_time, duration, radiant_win, game_mode, hero_id, player_slot, kills, deaths, assists (from list), leaver_status, rank | Full match: duration, first_blood_time, patch, scores; Per player: kills, deaths, assists, last_hits, denies, gpm, xpm, level, net_worth, hero_damage, tower_damage, hero_healing, items (0-5, backpack, neutral), aghs/shard/moonshard, gold, total_gold, total_xp, kda, benchmarks |\n');
	sections.push('| **Stratz** | id, durationSeconds, didRadiantWin, players: heroId, kills, assists, deaths, heroDamage, towerDamage, heroHealing, award, imp | Same in one query (no separate detail call) |\n');
	sections.push('| **Our DB Match** | match_id, account_id, hero_id, player_slot, radiant_win, start_time, game_mode, kills, deaths, assists, duration | Join MatchDetail/PlayersMatchDetail for hero_damage, hero_healing, tower_damage, last_hits, items, etc. |\n');

	const out = sections.join('\n');
	writeFileSync(OUT_FILE, out, 'utf-8');
	console.log('Wrote', OUT_FILE);
	console.log(out.slice(0, 1500) + '\n... (see file for full report)');
}

main().catch((e) => {
	console.error(e);
	process.exit(1);
});
